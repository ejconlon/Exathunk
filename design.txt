Codename "Exathunk"?

Bringing code to data on a planet scale.

Some loose notes

- Conventional web services:
  - Informally addressable (URL hierarchies)
  - Optionally typed (JSON + XML)
  - Only predefined server-side programs have local access to data,
    Extensible client-side programs must xfer data

- New functional web services:
  - Addressable by interface, with dependency injection
  - Well-typed
  - Choice of locality of data and execution of programs.

- UNIX philosophies
  - everything looks like a file
  - large programs are a composition of small programs
  - GNU philosophy - it's yours to do what you please

- Translated to planet scale computing
  - everything looks like a (Ref. Transp.) function
  - large functions are a composition of small functions
  - it's yours to run as you please if you know the function
    definitions/values you are using,
    otherwise, it's yours to reconfigure and run as you please as long
    as parties agree to access

- Federated computation is monadic!
  - The wrapped type is a non-federated (local) computation
  - return program - execute program in a federated context
    (solicit bids, organize units of work, profile execution)
  - join - first, note that federation has a tree structure
    (f (g x) (h y)) - Three points of federation,
      bid a = (g x)
      bid b = (h y)
      bid (f a b)
    Let F be the federation monad
    return (f (g x) (h y)) = join F f (return (g x)) (return (h y))
                           = join F f (F g x) (F h y)
                           = F f a b
  - What does it mean to bind?
    >>= :: m a -> (a -> m b) -> m b
    The function (a -> m b) takes a local computation
    And returns an execution strategy (federation?).

- Programs are like the ST monad, internally stateful and
  imperative, but RT at the boundary
- Federated computation is like the IO monad because it
  sequences effects (evaluation is an effect here),
  but again list the ST monad, the result is RT
- Non-deterministic computations "pollute" the tree -
  Let NF be the constructor for a the federation monad of
  non-deterministic program.  Then
  NF f (F g x) (F h y)  is well-typed but
  F f (NF g x) (NF g y) would not be (a pure computation cannot
  have non-deterministic sub-computations).

- It can be easier to optimize imperative programs (take advantage of mutation).
  There may also be some optimizations the programmer can make based on knowledge
  of the performance of sub-routines.  It is critical to *optionally* expose control of
  federation to the imperative program.  Can build execution strategies with map, reduce, etc

  For instance, if the result of your computation is Monoidal, 

  Given a function mreduce:
  mreduce :: Monoid x => [x] -> x
  mreduce x:xs = x `mappend` mreduce xs
  mreduce _ = mzero

  We can transform our program
  mreduce (map f xs) == mreduce (map f xs1) `mappend` mreduce (map f xs2)
  where xs == xs1 ++ xs2

  

TODO reread algorithm + strategy = parallelism paper
 

