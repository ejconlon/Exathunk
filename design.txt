Codename "Exathunk"?

Bringing code to data on a planet scale.

Some loose notes

- Conventional web services:
  - Informally addressable (URL hierarchies)
  - Optionally typed (JSON + XML)
  - Only predefined server-side programs have local access to data,
    Extensible client-side programs must xfer data

- New functional web services:
  - Addressable by interface, with dependency injection
  - Well-typed
  - Choice of locality of data and execution of programs.

- UNIX philosophies
  - everything looks like a file
  - large programs are a composition of small programs
  - GNU philosophy - it's yours to do what you please

- Translated to planet scale computing
  - everything looks like a (Ref. Transp.) function
  - large functions are a composition of small functions
  - it's yours to run as you please if you know the function
    definitions/values you are using,
    otherwise, it's yours to reconfigure and run as you please as long
    as parties agree to access

- Federated computation is monadic!
  - The wrapped type is a non-federated (local) computation
  - return program - execute program in a federated context
    (solicit bids, organize units of work, profile execution)
  - join - first, note that federation has a tree structure
    (f (g x) (h y)) - Three points of federation,
      bid a = (g x)
      bid b = (h y)
      bid (f a b)
    Let F be the federation monad
    return (f (g x) (h y)) = join F f (return (g x)) (return (h y))
                           = join F f (F g x) (F h y)
                           = F f a b
  - What does it mean to bind?
    >>= :: m a -> (a -> m b) -> m b
    The function (a -> m b) takes a local computation
    And returns an execution strategy (federation?).

- Programs are like the ST monad, internally stateful and
  imperative, but RT at the boundary
- Federated computation is like the IO monad because it
  sequences effects (evaluation is an effect here),
  but again list the ST monad, the result is RT
- Non-deterministic computations "pollute" the tree -
  Let NF be the constructor for a the federation monad of
  non-deterministic program.  Then
  NF f (F g x) (F h y)  is well-typed but
  F f (NF g x) (NF g y) would not be (a pure computation cannot
  have non-deterministic sub-computations).

- It can be easier to optimize imperative programs (take advantage of mutation).
  There may also be some optimizations the programmer can make based on knowledge
  of the performance of sub-routines.  It is critical to *optionally* expose control of
  federation to the imperative program.  Can build execution strategies with map, reduce, etc

  For instance, if the result of your computation is Monoidal, 

  Given a function mreduce:
  mreduce :: Monoid x => [x] -> x
  mreduce x:xs = x `mappend` mreduce xs
  mreduce _ = mzero

  We can transform our program
  mreduce (map f xs) == mreduce (map f xs1) `mappend` mreduce (map f xs2)
  where xs == xs1 ++ xs2

  What is the type of xs that decomposes?  It is splittable, and the parts are foldable

-- pulled from internets
class Foldable t where
    fold :: Monoid m => t m -> m
    foldMap :: Monoid m => (a -> m) -> t a -> m

    foldr :: (a -> b -> b) -> b -> t a -> b
    foldl :: (a -> b -> a) -> a -> t b -> a

    foldr1 :: (a -> a -> a) -> t a -> a
    foldl1 :: (a -> a -> a) -> t a -> a

class Splittable F a
    split :: F a -> Either a [F a]

instance (Splittable F a) => Foldable F a where
-- probably a very wrong def
fold :: (Monoid a) => m a -> a
fold t = go $ split t  where
     go Left fs = fs
     go Right [Split t] = foldl' mappend (map fold t)

something like that

So we want to fold an accumulator like
acc :: Monoid a => a -> b -> a
over a Splittable, which does NOT need to be over a monoid.

TODO reread algorithm + strategy = parallelism paper
 
Typeclasses for reference:
Functor F a
fmap :: (a -> b) -> F a -> F b
(square diagram)

Monad M a
return :: a -> M a
join :: M (M a) -> M a
>>= :: M a -> (a -> b) -> M b 
(How to write bind in terms of join, return, fmap?)

Comonad W a 
extract :: W a -> a
duplicate :: W a -> W (W a)

--

Thunk type:

A thunk will have the form

data Thunk arg res = Result res | Unevaluated FuncId arg 



